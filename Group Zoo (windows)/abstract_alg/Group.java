package abstract_alg;
/* NAME: Group.java
 * AUTHORS: Emma Bahlke (Primary), Alexi Block Gorman, and Meredith McCormack-Mager
 * DATE: May 2014
 * COMMENTS: This abstract class describes an algebraic finite Group object. It enshrines
 * the group axioms - EXCEPT for associativity - in the construction of the object
 * (closure under the group operation, plus containment of identity and inverses),
 * ensuring that every Group object is a valid group in the algebraic sense,
 * and provides extra methods for determining: the order of an element (see
 * GroupElement class); equality of two elements; normality and equality of subgroups;
 * and various helper methods.  Thus, this class can be used as a template for creating
 * a working code representation of any type of finite group.
 * MODIFIED: June 2, 2014 by Emma Bahlke.
 * */

import java.util.*;

public abstract class Group {
  protected GroupElement identity;
  protected int dimension; //This is the "n" in Z (mod n) and S_n and D_n, and it means different things 
                           //for different groups.  Helps determine the order of the group.
  protected LinkedList<GroupElement> members;
  protected Hashtable<Integer, LinkedList<GroupElement>> membersByOrder;
  protected LinkedList<Integer> allOrders; // for all possible *element* orders
  
  public Group(int n) {
   dimension = n;
   members = new LinkedList<GroupElement>();
  }
  
  /* This will return the number of elements in the group. */
  public abstract int getGroupOrder();
  
  /* Returns the identity. */
  public GroupElement getIdentity() {
    return identity;
  }
  
  /* This will perform the group operation (to be determined by the specific group)
   * on two group elements, and return the resulting group element. */
  public abstract GroupElement operate(GroupElement element1, GroupElement element2);
  
  /* Computes the inverse of a given element, i.e. the element f such that
   * operate(f, e) = operate(e, f) = identity. */
  public abstract GroupElement getInverse(GroupElement e);
  
  /* Computes the order of an element, i.e. how many times we need
   * to operate the element with itself before returning the identity. */
  public int computeElementOrder(GroupElement e) {
    int order = 1;
    GroupElement soFar = e;
    
    while (!equals(identity, soFar)) {
      soFar = operate(soFar, e);
      order++;
    }
    
    return order;
  }
  
  /* Determines whether or not two group elements are equal.
   * This may be overwritten in some groups, such as ZmodN,
   * because by nature they require information about the dimension
   * of the group to determine equality of two GroupElements. */
  public boolean equals(GroupElement one, GroupElement two) {
    return (one.equals(two));
  }
  
  /* Returns the cyclic subgroup generated by the element e. */
  public LinkedList<GroupElement> generateSubgroup(GroupElement e) {
    LinkedList<GroupElement> subgroup = new LinkedList<GroupElement>();
    subgroup.add(e);
    GroupElement soFar = e;
    
    while (!equals(soFar, identity)) {
      soFar = operate(soFar, e);
      addInOrder(subgroup, soFar);
    }
    
    return subgroup;
  }
  
  /* Tostring: */
  public abstract String toString();
  
    /* Returns the "name" of the group, such as S4, D7, etc. */
  public abstract String groupName();
  
  /* Goes through all the elements of the group and partitions them
   * based on their order, storing them in a Hashtable where each
   * possible element order corresponds to a LinkedList of elements
   * having that order. */
  public void storeElementsByOrder() {
    allOrders = new LinkedList<Integer>();
    LinkedList<GroupElement> membersCopy = getMembers();
    // ^ need the copy since we'll be removing elements from the members list
    
    // first, find all possible element orders:
    for (int i = 0; i < members.size(); i++) {
      if (!allOrders.contains(computeElementOrder(membersCopy.get(i))))
        allOrders = addInOrder(allOrders, computeElementOrder(membersCopy.get(i)));
    }
    
    membersByOrder = new Hashtable<Integer, LinkedList<GroupElement>>(allOrders.size());
    
    // next, to partition the elements based on their orders, or each possible order, we create a new
    // LinkedList for GroupElements of that order, then go through the membersCopy list
    // to find all elements of the current order under consideration, add them to sameOrderedElements,
    // and remove them from membersCopy as we go:
    for (int j = 0; j < allOrders.size(); j++) {
      LinkedList<GroupElement> sameOrderedElements = new LinkedList<GroupElement>();
      int k = 0; // keeps track of current position in membersCopy as we scan
        
      while (k < membersCopy.size()) {
        if (computeElementOrder(membersCopy.get(k)) == allOrders.get(j)) {
          sameOrderedElements.add(membersCopy.get(k));
          membersCopy.remove(k);
        }
        else
          k++;
      }
      
      membersByOrder.put(allOrders.get(j), sameOrderedElements);
    }
  }
  
  /* Returns the elements as sorted by order: */
  public Hashtable<Integer, LinkedList<GroupElement>> getElementsByOrder() {
    return membersByOrder;
  }
  
  /* Returns a neat toString representation of the membersByOrder hashtable: */
  public String orderedElementsToString() {
    String s = "This group has: ";
    
    for (int i = 0; i < allOrders.size(); i++) {
      LinkedList<GroupElement> current = membersByOrder.get(allOrders.get(i));
      s+="\n"+current.size()+((current.size() == 1) ? " element of order " : " elements of order ")+allOrders.get(i)+": "+
        current.toString();
    }
    
    return s;
  }
  
  /* Checks for the normality of a subgroup. The general process is outlined as
   * such: we go through all the members of the group one by one, taking each member
   * and then multiplying it on the RIGHT by every member of the subgroup (producing the
   * right coset) and on the LEFT (producing the left coset), and finally check for
   * equality of these cosets. If the left and right cosets are equal for every member
   * of the group, then the subgroup is normal. */
  public boolean isNormal(LinkedList<GroupElement> subgroup) {
    LinkedList<GroupElement> leftCoset = new LinkedList<GroupElement>();
    LinkedList<GroupElement> rightCoset = new LinkedList<GroupElement>();
    boolean val = true;
    int iteration = 1;
    // ^ start at 1 because 1st (0th) element of members is always the identity
    // (which by default produces equal left & right cosets)
    
    // note that we don't want to do extra work, so the second
    // we find even one unequal left and right coset, we stop our
    // calculations and return false (hence "while val")
    while (val && (iteration < members.size())) {
      for (int j = 0; j < subgroup.size(); j++) {
        leftCoset.add(operate(members.get(iteration), subgroup.get(j)));
        rightCoset.add(operate(subgroup.get(j), members.get(iteration)));
      }
      val = subgroupEquals(leftCoset, rightCoset);
      iteration++;
    }
    
    return val;
  }
  
  /* Returns the LinkedList representation of the members of the group. 
   * Note that it returns a "true copy" of the members list; this is because,
   * in the original iteration of the code where we simply had "return members",
   * the FactorGroup class would destroy the actual members list of the Group
   * instance fed to the FactorGroup constructor. */
  public LinkedList<GroupElement> getMembers() {
    LinkedList<GroupElement> members2 = new LinkedList<GroupElement>();
    
    for (int i = 0; i < members.size(); i++)
      members2.add(members.get(i));
    
    return members2;
  }
  
  /* Checks to see if two subgroups are equal, up to arrangement of elements. */
  protected boolean subgroupEquals(LinkedList<GroupElement> sg1, LinkedList<GroupElement> sg2) {
    if (sg1.size() != sg2.size())
      return false;
    else {
      for (int i = 0; i < sg1.size(); i++) {
        if (!contains(sg2, sg1.get(i)))
          return false;
      }
      return true;
    }
  }
  
  /* This helper method finds the index of a GroupElement e in a list of
   * GroupElements, returning -1 if the GroupElement could not be found.
   * Its existence is necessitated by the fact that the equality of two
   * group elements cannot be determined in the GroupElement class
   * Thus, we cannot use the LinkedList<T> "getIndex" or "contains" methods
   * (which require an equals method between objects of type T), and so this
   * helper method was born. */
  protected int findIndex(LinkedList<GroupElement> list, GroupElement e) {
    for (int i = 0; i < list.size(); i++) {
      if (equals(list.get(i), e)) {
        return i;
      }
    }
    return -1;
  }
  
  /* Similarly, we must write our own contains method: */
  protected boolean contains(LinkedList<GroupElement> list, GroupElement e) {
    return (findIndex(list, e) != -1);
  }
  
  /* Checks to see if some integer n is prime. */
  protected boolean isPrime(int n) {
    if (n%2 == 0) {
      if (n == 2)
        return true;
      else return false;
    }
    else {
      int ceiling = (int)Math.sqrt(n) + 1;
      
      // now we check if any of the numbers from 3 (since we know n is not even)
      // to the floor of n/2 divide n:
      for (int i = 3; i <= ceiling; i++) {
        if (i%n == 0)
          return false;
      }
      
      return true;
    }
  }
  
  /* Adds elements to the list in ascending order based on element order. */
  protected LinkedList<GroupElement> addInOrder(LinkedList<GroupElement> soFar, GroupElement toAdd) {
    for (int i = 0; i < soFar.size(); i++) {
      if (computeElementOrder(toAdd) <= computeElementOrder(soFar.get(i))) {
        soFar.add(i, toAdd);
        return soFar;
      }
    }
    
    soFar.add(toAdd);
    return soFar;
  }
  
  /* Adds an integer to a linked list of integers in order and returns
   * the new ordered list, ordered "lowest value first". */
  protected LinkedList<Integer> addInOrder(LinkedList<Integer> listSoFar, Integer toAdd) {
    if (listSoFar.size() == 0) {
      listSoFar.add(toAdd);
      return listSoFar;
    }
    for (int i = 0; i < listSoFar.size(); i++) {
      if (toAdd <= listSoFar.get(i)) {
        listSoFar.add(i, toAdd);
        return listSoFar;
      }
    }
    // otherwise, the toAdd element has the highest order so far and we just add it at the end:
    listSoFar.add(toAdd);
    return listSoFar;
  }
}